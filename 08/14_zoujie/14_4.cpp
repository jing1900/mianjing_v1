/*

问题：赛诗会上十二金钗各赋诗一首，12人各自随机挑选一首后，李纨曰：“大家通过两两交换的方式，换回自己的律诗；但要求只能跟我交换”。现已知：
黛玉、宝钗、元春、探春、湘云、妙玉、
迎春、惜春、熙凤、巧姐、李纨、可卿
各自拿到的律诗作者为：
熙凤、黛玉、迎春、惜春、湘云、可卿、
探春、元春、宝钗、巧姐、妙玉、李纨
试计算至少需要多少次交换，才能使得所有人交换得到自己的律诗？


分析：谁拿谁的，这个关系画出来，定能形成环。
比如
十二金钗分别标号为0,1,2,…,11，其中，李纨为0号。
题目实际上给定了12个整数的一个排列，要求只和0交换，最终形成升序数组，求最少的交换次数。
统计每个“环”的长度L：
    若包含0，则该环的最少交换次数为L-1；
	若不包含0，则该环的最少交换次数为1+L-1+1 = L+1次
将所有环的交换次数累积即可。
时间复杂度O(N)，空间复杂度O(N)

附加：两个聪明人A和B玩猜数字的游戏。他们在脑门上各贴一个正整数数字，两个数字只相差1，A和B只能看到对方的数而看不到自己的
以下是两人的对话：
	A：我不知道
	B：我也不知道
	A：我知道了
	B：我也知道了
上述4句对话结束后，聪明的你帮助A、B推算下，他们的数字各是多少呢？

分析：
若A1,B2,那么A会怀疑自己是1or3,说自己不知道，但B看到A，肯定确定自己是2,so,这种情况pass
若A2,B1,那么A肯定知道，so pass
若A4,B3,那么A看到3,猜测自己是2or4,说自己不知道，B会看到4,以为自己是3or5,所以也说不知道，
复杂的逻辑题可以用二叉树(N叉树)做辅助推理，原理是：只要某个结点的两个孩子(所有孩子)都不可能，则这个结点不可能。

注意：两人的说话顺序是有决定作用的，是不对称消息：
	A说话，则A是在看到B的内容后做判断，B可根据A的内容在自己的推理树上做剪枝。

*/

#include<bits/stdc++.h>
using namespace std;
class Solution
{
public:
    int exchange(vector<int> a,int n)
    {
        vector<bool> visited(n,0);//是否被访问过
        int j;
        int res =(a[0] == 0)?2:0;//最开始
        for(int i = 0;i<n;i++)
        {
            if(visited[i] || a[i] == i)
                continue;
            j = a[i];//j为a[i]的值，即黛玉最开始拿的诗，比如最开始为熙凤
            while(j!=i)//如果熙凤拿得诗不是黛玉
            {
                res++;//交换次数++
                visited[j] = true;//被访问过
                j = a[j];//看熙凤的诗
            }
            res+=2;//这么多环，只有一个带李纨的，所以统统加2
        }
        res-=2;//减去带李纨这个环的
        return res;

    }
};
int main()
{
    int N = 12;
    vector<int> a;
    for(int i = 0;i<N;i++)
        a.push_back(i);
    random_shuffle(a.begin(),a.end());
    Solution s;
    for(int i = 0;i<N;i++)
        cout<<a[i]<<" ";
    cout<<endl;
    cout<<s.exchange(a,N)<<endl;
    return 0;
}