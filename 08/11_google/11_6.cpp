/*问题： 给定一个字典，找到两个单词，它们不包含相同的字母，且乘积尽可能大，允许预处理字典。

分析：
方法1：先枚举单词，时间复杂度n^2, 然后如何判断单词之间不包含相同字母？
为每个单词设定一个签名，即用2^26次方bitmap表示每个字母是否出现了，出现为1,没出现为0
假设单词a签名为x，b为y，那么xy求亦或，若结果为1,那么有重复字母
n约为1-2w时，时间复杂度可以接受

方法2：预处理单词，将每个单词用整数x = [0,....2……26]表示，二进制转为的整数，比如abc，111都出现，则为7
，ac，为101,为5。这里不考虑每个单词出现的次数，只考虑出不出现

然后给定状态s，表示单词的字母出现次数可以为s的字迹，比如s = 7（111），则说明只能出现abc，当然abc可以不出现，只要是子集就好

如何计算dp[s]?s= 7 ,包括abc，ab，ac，bc，a，b，c.因此，dp[s]的值应为所有这些子集单词中长度最长的。再次重申，s的值表示允许出现哪些字母

我们处理的过程如下，首先dp[*]初始化为0.

然后对于某个单词的签名x,dp[x] = max(dp[x],len(word)].//有单词的可以填初值了，就是单词的长度，比如abc，dp[7] = 3

然后更新s（0, 2^26-1）,s‘为s少一个二进制1的状态，比如s = 10110,s' = 00110,10010,10100,
dp[s] = max(dp[s],dp[s']).即子集的最优解，要么是它的子集中最好的，要么是它本身（预处理好了）

那么结果如何取呢？

max(len(x)*dp[~x&((1<<26)-1)])//前面表示x这个签名代表的单词的长度，后面表示取反后的子集，并只取前26位